## Задача 1

Исследование виртуальной стековой машины CPython.

Изучите возможности просмотра байткода ВМ CPython.

```Python
import dis

def foo(x):
    while x:
        x -= 1
    return x + 1

print(dis.dis(foo))
```

Опишите по шагам, что делает каждая из следующих команд (приведите эквивалентное выражение на Python):

 11           0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (10)
              4 BINARY_MULTIPLY
              6 LOAD_CONST               2 (42)
              8 BINARY_ADD
             10 RETURN_VALUE

## Решение:

> Пошаговое описание команд:
```LOAD_FAST 0 (x)```

Действие: Загружает значение локальной переменной x в стек.
Стек после выполнения: [x]

```LOAD_CONST 1 (10)```
Действие: Загружает константу 10 в стек.
Стек после выполнения: [x, 10]

```BINARY_MULTIPLY```
Действие: Извлекает два верхних элемента из стека (x и 10), умножает их, и результат (x * 10) помещает обратно в стек.
Стек после выполнения: [x * 10]

```LOAD_CONST 2 (42)```
Действие: Загружает константу 42 в стек.
Стек после выполнения: [x * 10, 42]

```BINARY_ADD```
Действие: Извлекает два верхних элемента из стека (x * 10 и 42), складывает их, и результат (x * 10 + 42) помещает обратно в стек.
Стек после выполнения: [x * 10 + 42]

```RETURN_VALUE```
Действие: Извлекает верхнее значение из стека (x * 10 + 42) и возвращает его как результат выполнения функции.
Стек после выполнения: []


## Эквивалентный код на Python:

```
def compute(x):
    return x * 10 + 42
```

## Задача 2

Что делает следующий байткод (опишите шаги его работы)? Это известная функция, назовите ее.

```Python
  5           0 LOAD_CONST               1 (1)
              2 STORE_FAST               1 (r)

  6     >>    4 LOAD_FAST                0 (n)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       30

  7          12 LOAD_FAST                1 (r)
             14 LOAD_FAST                0 (n)
             16 INPLACE_MULTIPLY
             18 STORE_FAST               1 (r)

  8          20 LOAD_FAST                0 (n)
             22 LOAD_CONST               1 (1)
             24 INPLACE_SUBTRACT
             26 STORE_FAST               0 (n)
             28 JUMP_ABSOLUTE            4

  9     >>   30 LOAD_FAST                1 (r)
             32 RETURN_VALUE
```

> Пошаговое описание команд:

```LOAD_CONST 1 (1)```
Действие: Загружает константу 1 в стек.
Стек после выполнения: [1]

```STORE_FAST 1 (r)```
Действие: Извлекает верхнее значение из стека (1) и сохраняет его в локальную переменную r.
Состояние переменных: r = 1
Стек после выполнения: []

```LOAD_FAST 0 (n)```
Действие: Загружает значение локальной переменной n в стек.
Стек после выполнения: [n]

```LOAD_CONST 1 (1)```
Действие: Загружает константу 1 в стек.
Стек после выполнения: [n, 1]

```COMPARE_OP 4 (>)```
Действие: Выполняет операцию сравнения n > 1.
Результат: Булево значение True, если n больше 1, иначе False.
Стек после выполнения: [n > 1]

```POP_JUMP_IF_FALSE 30```
Действие: Если результат сравнения n > 1 равен False, выполняет переход к инструкции с адресом 30. В противном случае продолжает выполнение следующих инструкций.
Логика: Если n не больше 1, завершает цикл и переходит к возврату результата.

```LOAD_FAST 1 (r)```

Действие: Загружает текущее значение переменной r в стек.
Стек после выполнения: [r]

```LOAD_FAST 0 (n)```
Действие: Загружает текущее значение переменной n в стек.
Стек после выполнения: [r, n]

```INPLACE_MULTIPLY```
Действие: Выполняет операцию r *= n, то есть умножает текущее значение r на n и сохраняет результат обратно в r.
Состояние переменных: r = r * n
Стек после выполнения: [r * n]

```STORE_FAST 1 (r)```
Действие: Сохраняет результат умножения обратно в переменную r.
Стек после выполнения: []

```LOAD_FAST 0 (n)```
Действие: Загружает текущее значение переменной n в стек.
Стек после выполнения: [n]

```LOAD_CONST 1 (1)```
Действие: Загружает константу 1 в стек.
Стек после выполнения: [n, 1]

```INPLACE_SUBTRACT```
Действие: Выполняет операцию n -= 1, то есть уменьшает значение n на 1 и сохраняет результат обратно в n.
Состояние переменных: n = n - 1
Стек после выполнения: [n - 1]

```STORE_FAST 0 (n)```
Действие: Сохраняет результат вычитания обратно в переменную n.
Стек после выполнения: []

```JUMP_ABSOLUTE 4```
Действие: Безусловно переходит к инструкции с адресом 4, что соответствует началу цикла проверки условия n > 1.

```LOAD_FAST 1 (r)```
Действие: Загружает итоговое значение переменной r в стек для возврата.
Стек после выполнения: [r]

```RETURN_VALUE```
Действие: Возвращает верхнее значение из стека (r) как результат выполнения функции.
Стек после выполнения: []

### Эквивалентный код на Python:

Этот байткод эквивалентен следующему коду Python, который вычисляет факториал числа `n` с помощью цикла:

```python
def factorial(n):
    r = 1
    while n > 1:
        r *= n
        n -= 1
    return r
```

Название функции -  вычисления факториала числа

## Задача 3

Приведите результаты из задач 1 и 2 для виртуальной машины JVM (Java) или .Net (C#).

## Решение:

### Задача 1 (выражение `x * 10 + 42`):
```java
import java.util.Scanner;

public class Task1 {
    public static int calculate(int x) {
        return x * 10 + 42;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите число x: ");
        int x = scanner.nextInt();

        int result = calculate(x);
        System.out.println("Результат: " + result);
    }
}
```

### Байткод JVM для функции `calculate`

```
public static int calculate(int);
  Code:
     0: iload_0           // Загружаем x в стек
     1: bipush 10         // Загружаем константу 10 в стек
     3: imul              // Умножаем x на 10
     4: bipush 42         // Загружаем константу 42 в стек
     6: iadd              // Складываем результат умножения с 42
     7: ireturn           // Возвращаем итоговое значение
```

### Задача 2 (факториал):

```java
import java.util.Scanner;

public class Task2 {
    public static int factorial(int n) {
        int r = 1;
        while (n > 1) {
            r *= n;
            n -= 1;
        }
        return r;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите число для вычисления факториала: ");
        int n = scanner.nextInt();

        int result = factorial(n);
        System.out.println("Факториал: " + result);
    }
}
```

### Байткод JVM для функции `factorial`

```
public static int factorial(int);
  Code:
     0: iconst_1              // Инициализируем r = 1
     1: istore_1              // Сохраняем значение 1 в переменную r
     2: iload_0               // Загружаем значение n в стек
     3: iconst_1              // Загружаем константу 1 в стек
     4: if_icmple 22          // Проверяем, n > 1; если нет, переходим к завершению
     7: iload_1               // Загружаем r в стек
     8: iload_0               // Загружаем n в стек
     9: imul                  // Умножаем r на n
    10: istore_1              // Сохраняем результат в r
    11: iload_0               // Загружаем n в стек
    12: iconst_1              // Загружаем 1 в стек
    13: isub                  // Вычитаем 1 из n
    14: istore_0              // Сохраняем результат в n
    15: goto 2                // Переход к началу цикла
    22: iload_1               // Загружаем r в стек (итоговый результат)
    23: ireturn               // Возвращаем r
```
